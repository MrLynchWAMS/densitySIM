<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Interactive Density Lab</title>
  <link rel="icon" href="data:image/svg+xml,&lt;svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22&gt;&lt;text y=%22.9em%22 font-size=%2290%22&gt;üéà&lt;/text&gt;&lt;/svg%3E">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Inter', sans-serif; touch-action: none; }
    .grab { cursor: grab; }
    .grabbing { cursor: grabbing; z-index: 1000; transform: scale(1.05); box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
    .beaker { width: 150px; height: 300px; border: 4px solid #9ca3af; border-top: none; border-radius: 0 0 20px 20px; position: relative; background-color: #f0f9ff; box-shadow: inset 0 2px 8px rgba(0,0,0,0.1); }
    .water { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to bottom, #7dd3fc 0%, #0ea5e9 100%); opacity: 0.75; transition: height 0.3s ease-out, background 0.3s ease; }
    .water.overflow { background: linear-gradient(to bottom, #fb7185 0%, #e11d48 100%); }
    .water-surface { position: absolute; top: 0; left: -2%; right: -2%; height: 10px; background-color: #38bdf8; border-radius: 50%; opacity: 0.8; transition: background-color 0.3s ease; }
    .water.overflow .water-surface { background-color: #f43f5e; }
    .beaker-markings { position: absolute; top: 0; right: 5px; bottom: 0; width: 20px; display: flex; flex-direction: column-reverse; justify-content: flex-start; }
    .beaker-markings span { font-size: 10px; color: #4b5563; height: 30px; border-top: 1px solid #6b7280; text-align: right; position: relative; }
    .beaker-markings span::before { content: attr(data-label); position: absolute; right: 15px; top: -8px; }
    .lab-object { transition: transform 0.2s ease-out, box-shadow 0.2s ease-out; z-index: 10; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(0,0,0,0.1); }
    .object-shelf { background-color: #e2e8f0; padding: 0.75rem; border-radius: 0.5rem; min-height: 80px; border: 2px dashed transparent; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out; }
    .object-shelf.drop-active { background-color: #e0f2fe; border-color: #38bdf8; }
    .object-shelf .lab-object { position: relative; display: inline-flex; margin: 8px; }
    input[type=range][orient=vertical] { writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 8px; height: 175px; padding: 0 5px; }
    [contenteditable] { outline: 2px dashed transparent; transition: outline-color 0.2s, background-color 0.2s; border-radius: 4px; padding: 2px 4px; min-width: 30px; }
    [contenteditable]:focus { outline-color: #38bdf8; background-color: #eff6ff; }
    [contenteditable]:hover { background-color: #f0f9ff; }
    select { appearance: none; background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e"); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
    .feedback-icon { display: inline-block; font-size: 1.2em; animation: fadeIn 0.3s ease-in; }
    @keyframes fadeIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
    .highlight-scale { animation: pulse 1.5s ease-in-out infinite; }
    .highlight-beaker { animation: pulse 1.5s ease-in-out infinite; animation-delay: 0.3s; }
    .water-level-marker { position: absolute; right: -30px; width: 25px; height: 2px; background-color: #1e40af; opacity: 0.7; pointer-events: none; }
    .water-level-marker::after { content: attr(data-volume); position: absolute; right: 30px; top: -8px; font-size: 11px; color: #1e40af; font-weight: bold; white-space: nowrap; }
    #help-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 9999; justify-content: center; align-items: center; }
    #help-modal.show { display: flex; }
    .modal-content { background: white; border-radius: 1rem; padding: 2rem; max-width: 600px; max-height: 80vh; overflow-y: auto; box-shadow: 0 20px 25px -5px rgba(0,0,0,0.1); }
  </style>
</head>
<body class="bg-slate-100 text-slate-800 antialiased">

<div id="simulation-container" class="container mx-auto p-4 md:p-8 h-screen flex flex-col">
  <header class="text-center mb-4">
    <h1 class="text-4xl font-bold text-slate-900">Interactive Density Lab</h1>
    <p class="text-lg text-slate-600 mt-2">Measure, calculate, and discover the density of various materials!</p>
    <div class="mt-4 flex justify-center items-center gap-4">
      <label for="difficulty-select" class="font-semibold text-slate-700">Difficulty Level:</label>
      <select id="difficulty-select" class="px-4 py-2 w-56 text-base border-2 border-slate-300 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 rounded-lg focus:shadow-lg transition-all duration-200 ease-in-out">
        <option value="1" selected>Level 1 - Beginner</option>
        <option value="2">Level 2 - Intermediate</option>
        <option value="3">Level 3 - Advanced</option>
        <option value="4">Challenge Mode</option>
      </select>
      <button id="help-btn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-transform transform hover:scale-105">‚ùì Help</button>
    </div>
  </header>

  <div class="flex-grow grid grid-cols-1 lg:grid-cols-[1.5fr_3fr_2.5fr] gap-8 min-h-0">
    <!-- Left Panel -->
    <div class="bg-white p-6 rounded-2xl shadow-lg flex flex-col">
      <h2 class="text-2xl font-bold mb-4 border-b pb-2">Materials</h2>

      <!-- Calculator -->
      <div id="calculator" class="mb-4 p-3 bg-slate-50 rounded-lg border-2 border-slate-200">
        <div id="calc-display" class="bg-slate-800 text-white text-right rounded-md p-2 mb-3 font-mono text-xl h-12 flex items-center justify-end overflow-x-auto">0</div>
        <div id="calc-buttons" class="grid grid-cols-4 gap-2 text-slate-700 font-bold">
          <button class="py-2 bg-red-200 hover:bg-red-300 rounded-md" data-value="clear">C</button>
          <button class="py-2 bg-slate-200 hover:bg-slate-300 rounded-md" data-value="(">(</button>
          <button class="py-2 bg-slate-200 hover:bg-slate-300 rounded-md" data-value=")">)</button>
          <button class="py-2 bg-orange-400 hover:bg-orange-500 text-white rounded-md" data-value="/">√∑</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="7">7</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="8">8</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="9">9</button>
          <button class="py-2 bg-orange-400 hover:bg-orange-500 text-white rounded-md" data-value="*">√ó</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="4">4</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="5">5</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="6">6</button>
          <button class="py-2 bg-orange-400 hover:bg-orange-500 text-white rounded-md" data-value="-">‚àí</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="1">1</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="2">2</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="3">3</button>
          <button class="py-2 bg-orange-400 hover:bg-orange-500 text-white rounded-md" data-value="+">+</button>
          <button class="col-span-2 py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value="0">0</button>
          <button class="py-2 bg-white hover:bg-slate-100 rounded-md border border-slate-200" data-value=".">.</button>
          <button class="py-2 bg-indigo-500 hover:bg-indigo-600 text-white rounded-md" data-value="=">=</button>
        </div>
      </div>

      <div class="space-y-4 flex-grow">
        <div>
          <h3 class="text-xl font-semibold mb-2">Known Materials</h3>
          <div id="known-object-container" class="object-shelf"></div>
        </div>
        <div>
          <h3 class="text-xl font-semibold mb-2">Mystery Objects</h3>
          <div id="mystery-object-container" class="object-shelf"></div>
        </div>
      </div>

      <button id="reset-btn" class="mt-auto w-full bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-6 rounded-lg transition-transform transform hover:scale-105">üîÑ New Challenge</button>
    </div>

    <!-- Center Panel -->
    <div id="lab-area" class="bg-white p-6 rounded-2xl shadow-lg relative flex flex-col justify-between h-full">
      <div id="overflow-warning" class="absolute top-2 right-2 text-red-600 font-bold bg-white/80 p-2 rounded hidden z-20">‚ö†Ô∏è OVERFLOW! Measurement invalid.</div>
      <div id="measurement-hint" class="absolute top-2 left-2 text-indigo-600 font-semibold bg-indigo-50 border-2 border-indigo-300 p-3 rounded-lg hidden z-20 max-w-xs"></div>
    </div>

    <!-- Right Panel -->
    <div class="bg-white p-6 rounded-2xl shadow-lg overflow-y-auto">
      <h2 class="text-2xl font-bold mb-4 border-b pb-2">Lab Results</h2>

      <div class="bg-blue-50 border-2 border-blue-200 rounded-lg p-4 mb-4">
        <h3 class="font-bold text-blue-900 mb-2">üìã Procedure:</h3>
        <ol class="text-sm text-blue-800 space-y-1 list-decimal list-inside">
          <li>Drag object to <strong>scale</strong> ‚Üí record mass</li>
          <li>Drag object to <strong>beaker</strong> ‚Üí record volume change</li>
          <li><strong>Calculate</strong> density: D = M √∑ V</li>
          <li>Compare mystery densities to known materials</li>
        </ol>
      </div>

      <div id="submission-info" class="hidden mb-4 p-3 bg-indigo-50 border-2 border-indigo-200 rounded-lg">
        <h3 class="font-bold text-indigo-900 mb-2">Submission History:</h3>
        <div id="submission-list" class="text-sm text-indigo-800 space-y-2"></div>
      </div>

      <div class="bg-amber-50 border-2 border-amber-300 rounded-lg p-3 mb-4">
        <p class="text-sm text-amber-900 font-semibold">üí° Formula: Density = Mass √∑ Volume</p>
        <p class="text-xs text-amber-800 mt-1">Example: 27g √∑ 10mL = 2.7 g/mL</p>
      </div>

      <div class="space-y-6">
        <div>
          <h3 class="font-semibold mb-2">Known Materials</h3>
          <table class="w-full text-left text-sm">
            <thead class="text-xs text-slate-600 uppercase bg-slate-50">
            <tr><th class="p-2">Material</th><th class="p-2">Mass (g)</th><th class="p-2">Volume (mL)</th><th class="p-2">Density (g/mL)</th></tr>
            </thead>
            <tbody id="known-results-body"></tbody>
          </table>
        </div>

        <div class="flex justify-between items-center mb-2">
          <h3 class="font-semibold flex items-center gap-4">Mystery Objects</h3>
          <div id="score-display" class="font-bold text-lg text-slate-800 pr-2 hidden"></div>
        </div>
        <table class="w-full text-left text-sm">
          <thead class="text-xs text-slate-600 uppercase bg-slate-50">
          <tr><th class="p-2">Object</th><th class="p-2">Mass (g)</th><th class="p-2">Volume (mL)</th><th class="p-2">Density (g/mL)</th><th class="p-2">Identification</th><th class="p-2">Result</th></tr>
          </thead>
          <tbody id="mystery-results-body"></tbody>
        </table>
        <div class="flex gap-2 mt-4">
          <button id="check-answers-btn" class="flex-1 text-sm bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg transition-transform transform hover:scale-105">‚úì Check Answers</button>
          <button id="export-btn" class="flex-1 text-sm bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-3 rounded-lg transition-transform transform hover:scale-105">üì§ Export Results</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Export Modal -->
<div id="export-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-[10000]">
  <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-lg w-full m-4">
    <h2 class="text-2xl font-bold mb-4">üîó Your Shareable Link</h2>
    <p class="text-slate-600 mb-4">Copy this link to save your progress or share your completed lab results with your teacher.</p>
    <textarea id="export-link" class="w-full p-3 border-2 border-slate-300 rounded-lg bg-slate-50 text-sm" readonly rows="4"></textarea>
    <div class="mt-6 flex justify-end gap-4">
      <button id="copy-link-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-5 rounded-lg transition-transform transform hover:scale-105">Copy Link</button>
      <button id="close-export-modal-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-5 rounded-lg">Close</button>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', async () => {
  // Constants you can tune
  const gravity = 0.5;
  const beakerCapacity = 300;
  const waterHeightPerML = 300 / beakerCapacity;

  // Water-only damping and constraints
  const waterLinearDrag = 0.90; // in-water drag
  const surfaceDamping = 0.70;  // extra damping when partially submerged and buoyant
  const maxVyInWater = 8;       // cap in-water vertical speed
  const maxVyOverall = 18;      // global vertical speed cap (prevents tunneling)

  // Scale readout stabilization
  const scaleLatchBufferY = 14; // pixels above platform to latch
  const scaleLatchBufferX = 6;  // pixels extra horizontal tolerance
  const scaleReleaseFrames = 6; // frames outside zone before unlatch
  const scaleStableThreshold = 6; // frames latched before we trust the readout

  // Difficulty mystery counts (chosen from level's known list)
  const MYSTERY_COUNT = { 1: 2, 2: 3, 3: 4, 4: 5 };

  // Materials
  const KNOWN_MATERIALS_REPO = [
    { id: 'Gold', density: 19.3, color: 'bg-yellow-400', baseVolume: 5, shape: 'rounded-sm', size: 'w-8 h-8' },
    { id: 'Lead', density: 11.34, color: 'bg-gray-600', baseVolume: 10, shape: 'rounded-lg', size: 'w-10 h-10' },
    { id: 'Zinc', density: 7.14, color: 'bg-blue-200', baseVolume: 8, shape: 'rounded-sm', size: 'w-8 h-8' },
    { id: 'Titanium', density: 4.54, color: 'bg-gray-400', baseVolume: 12, shape: 'rounded-lg', size: 'w-10 h-10' },
    { id: 'Copper', density: 8.96, color: 'bg-orange-600', baseVolume: 7, shape: 'rounded-md', size: 'w-9 h-9' },
    { id: 'Aluminum', density: 2.7, color: 'bg-slate-300', baseVolume: 15, shape: 'rounded-md', size: 'w-12 h-8' },
    { id: 'Marble', density: 2.71, color: 'bg-stone-200', baseVolume: 15, shape: 'rounded-full', size: 'w-10 h-10' },
    { id: 'Steel', density: 7.85, color: 'bg-gray-500', baseVolume: 9, shape: 'rounded-sm', size: 'w-9 h-9' },
    { id: 'Brick', density: 1.92, color: 'bg-red-400', baseVolume: 18, shape: 'rounded-none', size: 'w-12 h-6' },
    { id: 'Glass', density: 2.5, color: 'bg-cyan-100', baseVolume: 16, shape: 'rounded-md', size: 'w-11 h-7' },
    { id: 'PVC', density: 1.38, color: 'bg-neutral-100', baseVolume: 22, shape: 'rounded-xl', size: 'w-16 h-5' },
    { id: 'Ice', density: 0.92, color: 'bg-cyan-200', baseVolume: 20, shape: 'rounded-full', size: 'w-10 h-10' },
    { id: 'Wax', density: 0.95, color: 'bg-yellow-100', baseVolume: 19, shape: 'rounded-md', size: 'w-11 h-8' },
    { id: 'OakWood', name: 'Oak Wood', density: 0.75, color: 'bg-amber-600', baseVolume: 25, shape: 'rounded-xl', size: 'w-14 h-6' },
    { id: 'Cork', density: 0.24, color: 'bg-amber-700', baseVolume: 28, shape: 'rounded-md', size: 'w-12 h-9' },
    { id: 'Styrofoam', density: 0.05, color: 'bg-white', baseVolume: 30, shape: 'rounded-lg', size: 'w-14 h-8' },
    { id: 'AirBubble', name: 'Air Bubble', density: 0.001, color: 'bg-blue-50', baseVolume: 35, shape: 'rounded-full', size: 'w-12 h-12' }
  ];

  // Simple style palette for mystery objects
  const MYSTERY_STYLE_POOL = [
    { color: 'bg-purple-400', shape: 'rounded-lg', size: 'w-12 h-12' },
    { color: 'bg-teal-400', shape: 'rounded-md', size: 'w-16 h-8' },
    { color: 'bg-pink-400', shape: 'rounded-full', size: 'w-14 h-14' },
    { color: 'bg-orange-400', shape: 'rounded-none', size: 'w-10 h-10' },
    { color: 'bg-lime-400', shape: 'rounded-xl', size: 'w-14 h-8' },
    { color: 'bg-green-300', shape: 'rounded-lg', size: 'w-11 h-11' },
    { color: 'bg-indigo-300', shape: 'rounded-md', size: 'w-13 h-9' },
    { color: 'bg-rose-200', shape: 'rounded-xl', size: 'w-15 h-7' },
    { color: 'bg-amber-300', shape: 'rounded-sm', size: 'w-11 h-11' },
    { color: 'bg-yellow-200', shape: 'rounded-lg', size: 'w-12 h-9' }
  ];

  const DIFFICULTY_CONFIG = {
    1: { knownMaterials: ['Zinc', 'Lead', 'Marble', 'Brick'], mysteryCount: MYSTERY_COUNT[1], measurementError: 0 },
    2: { knownMaterials: ['Gold', 'Titanium', 'PVC', 'Ice'], mysteryCount: MYSTERY_COUNT[2], measurementError: 0 },
    3: { knownMaterials: ['Aluminum', 'Steel', 'OakWood', 'Cork'], mysteryCount: MYSTERY_COUNT[3], measurementError: 0 },
    4: { knownMaterials: ['Copper', 'Glass', 'Wax', 'Styrofoam', 'AirBubble'], mysteryCount: MYSTERY_COUNT[4], measurementError: 0.02 }
  };

  // DOM refs
  const labArea = document.getElementById('lab-area');
  const knownObjectContainer = document.getElementById('known-object-container');
  const mysteryObjectContainer = document.getElementById('mystery-object-container');
  const knownResultsBody = document.getElementById('known-results-body');
  const mysteryResultsBody = document.getElementById('mystery-results-body');
  const resetBtn = document.getElementById('reset-btn');
  const overflowWarning = document.getElementById('overflow-warning');
  const difficultySelect = document.getElementById('difficulty-select');
  const checkAnswersBtn = document.getElementById('check-answers-btn');
  const helpBtn = document.getElementById('help-btn');
  const measurementHint = document.getElementById('measurement-hint');
  const exportBtn = document.getElementById('export-btn');

  let objects = [];
  let draggedObject = null;
  let liquidDensity = 1.0;
  let initialWaterLevel = 100;
  let currentDifficulty = 2;
  let sessionData = {};
  let initialWaterLevelMarker = null;
  let score = 0;

  // scale readout latch
  let lastStableScaleMass = 0;

  // dynamic elements created later
  let scaleEl, beakerEl, waterEl, liquidDensitySlider, initialWaterSlider;

  // Global listeners
  document.addEventListener('mousedown', startDrag);
  document.addEventListener('touchstart', startDrag, { passive: false });
  document.addEventListener('mousemove', drag);
  document.addEventListener('touchmove', drag, { passive: false });
  document.addEventListener('mouseup', endDrag);
  document.addEventListener('touchend', endDrag);

  resetBtn.addEventListener('click', () => {
    if (window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
    init(); gameLoop();
  });
  difficultySelect.addEventListener('change', () => {
    if (window.animationFrameId) cancelAnimationFrame(window.animationFrameId);
    init(); gameLoop();
  });
  checkAnswersBtn.addEventListener('click', checkAnswers);
  exportBtn.addEventListener('click', handleExport);

  document.getElementById('close-export-modal-btn').addEventListener('click', () => {
    document.getElementById('export-modal').style.display = 'none';
  });
  document.getElementById('copy-link-btn').addEventListener('click', () => {
    const linkText = document.getElementById('export-link'); linkText.select();
    document.execCommand('copy'); alert('Link copied to clipboard!');
  });

  // Calculator
  const calcDisplay = document.getElementById('calc-display');
  const calcButtons = document.getElementById('calc-buttons');
  calcButtons.addEventListener('click', (e) => {
    if (e.target.tagName !== 'BUTTON') return;
    const value = e.target.dataset.value;
    const displaySymbol = e.target.textContent;
    let currentDisplay = calcDisplay.textContent;
    if (currentDisplay === 'Error' || (currentDisplay === '0' && value !== '.' && value !== '(')) currentDisplay = '';
    switch (value) {
      case 'clear': currentDisplay = '0'; break;
      case '=':
        try {
          const expression = currentDisplay.replace(/√ó/g, '*').replace(/√∑/g, '/');
          const result = new Function('return ' + expression)();
          currentDisplay = (isNaN(result) || !isFinite(result)) ? 'Error' : result.toFixed(2);
        } catch { currentDisplay = 'Error'; }
        break;
      case '.':
        const lastNumber = currentDisplay.split(/[\+\-\√ó\√∑\(\)]/).pop();
        if (!lastNumber.includes('.')) currentDisplay += displaySymbol;
        break;
      default: currentDisplay += displaySymbol; break;
    }
    calcDisplay.textContent = currentDisplay;
  });

  helpBtn.addEventListener('click', () => {
    document.getElementById('help-modal').classList.add('show');
  });
  document.addEventListener('click', (e) => {
    const modal = document.getElementById('help-modal');
    if (modal && (e.target.id === 'help-modal' || e.target.id === 'close-help' || e.target.id === 'close-help-btn')) {
      modal.classList.remove('show');
    }
  });

 
function collectCurrentTableData() {
  const data = {};
  document.querySelectorAll('#known-results-body tr, #mystery-results-body tr').forEach(row => {
    const rowId = row.id;
    if (!rowId) return;

    const firstCell = row.querySelector('td');
    const isMystery = row.parentElement && row.parentElement.id === 'mystery-results-body';

    data[rowId] = {
      label: firstCell ? firstCell.textContent.trim() : '',
      isMystery
    };

    const massCell = row.querySelector('[data-col="mass"]');
    const volumeCell = row.querySelector('[data-col="volume"]');
    const densityCell = row.querySelector('[data-col="density"]');
    const idSelect = row.querySelector('[data-col="identification"]');
    const resultCell = row.querySelector('[data-col="result"]');

    if (massCell) data[rowId].mass = massCell.textContent;
    if (volumeCell) data[rowId].volume = volumeCell.textContent;
    if (densityCell) data[rowId].density = densityCell.textContent;
    if (idSelect) data[rowId].identification = idSelect.value || '';

    // Save the displayed result output exactly as rendered (keeps ‚úì/‚úó and styling if present)
    if (resultCell) data[rowId].result = resultCell.innerHTML.trim();

    // Snapshot whether this row was marked correct at submission time
    data[rowId].isCorrect = row.classList.contains('is-correct');

    // For mystery rows, also capture the ground truth used in this session
    if (isMystery) {
      const objLabel = (firstCell && firstCell.textContent || '').replace(/^Object\s+/, '').trim(); // e.g., "A", "B"
      const obj = objects.find(o => o.data.isMystery && (o.data.id === objLabel));
      if (obj) {
        data[rowId].expected = {
          answerId: obj.data.answerId || obj.data.id,
          trueDensity: obj.data.trueDensity
        };
      }
    }
  });
  return data;
}

// REPLACE the existing handleExport with this version
async function handleExport() {
  let studentName = prompt("Please enter your first name to include in the report:", "");
  if (studentName === null || studentName.trim() === "") {
    alert("Export cancelled. You must provide a name.");
    return;
  }
  studentName = studentName.trim();

  // If this page was opened via a share link, include prior submission as history
  const urlParams = new URLSearchParams(window.location.search);
  const existingDataParam = urlParams.get('data');
  let history = [];

  if (existingDataParam) {
    try {
      const binaryString = atob(existingDataParam);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
      const jsonString = pako.inflate(bytes, { to: 'string' });
      const prevData = JSON.parse(jsonString);
      history = prevData.history || [];
      if (prevData.current) history.push(prevData.current);
    } catch (e) {
      console.warn("Could not parse previous submission data. Starting fresh history.", e);
    }
  }

  // Snapshot everything visible in the tables, including result outputs and correctness flags
  const currentTableData = collectCurrentTableData();

  const dataToSave = {
    history: history,
    current: {
      name: studentName,
      timestamp: new Date().toISOString(),
      difficulty: currentDifficulty,
      score: score,
      sessionData: currentTableData
    }
  };

  try {
    const jsonString = JSON.stringify(dataToSave);
    const compressed = pako.deflate(jsonString);

    let binary = '';
    const len = compressed.byteLength;
    for (let i = 0; i < len; i++) binary += String.fromCharCode(compressed[i]);
    const encodedData = btoa(binary);

    // Build a base URL using the current page, so results open on the same path (no density2.html forcing)
    const baseHref = (() => {
      try {
        const u = new URL(window.location.href);
        u.search = '';
        u.hash = '';
        return u.href; // same page, no query/hash
      } catch {
        // Defensive fallback: strip query/hash manually if URL constructor isn't available
        const href = (window.location && window.location.href) || '';
        return href.split('#')[0].split('?')[0];
      }
    })();

    const url = new URL(baseHref);
    url.searchParams.set('data', encodedData);

    const exportLink = document.getElementById('export-link');
    exportLink.value = url.href;
    document.getElementById('export-modal').style.display = 'flex';
  } catch (error) {
    console.error("Failed to export data:", error);
    alert("An error occurred while trying to generate the link.");
  }
}

// REPLACE the existing handleImport with this version
async function handleImport() {
  const urlParams = new URLSearchParams(window.location.search);
  const data = urlParams.get('data'); if (!data) return false;

  try {
    const binaryString = atob(data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) bytes[i] = binaryString.charCodeAt(i);
    const jsonString = pako.inflate(bytes, { to: 'string' });
    const loadedDataWrapper = JSON.parse(jsonString);
    if (!loadedDataWrapper.current) throw new Error("Invalid data structure.");

    const loadedData = loadedDataWrapper.current;
    const history = loadedDataWrapper.history || [];
    const allSubmissions = [...history, loadedData];

    const submissionInfoDiv = document.getElementById('submission-info');
    const submissionList = document.getElementById('submission-list');
    submissionList.innerHTML = '';
    allSubmissions.forEach((submission, index) => {
      const date = new Date(submission.timestamp);
      const entry = document.createElement('div');
      entry.className = (index < allSubmissions.length - 1 ? 'border-b border-indigo-200 pb-2' : '');
      entry.innerHTML = `<strong>${submission.name}</strong> submitted on <strong>${date.toLocaleString()}</strong> (Score: ${submission.score}%)`;
      submissionList.appendChild(entry);
    });
    submissionInfoDiv.classList.remove('hidden');

    // Initialize the UI for the right difficulty (we'll use it in read-only mode)
    difficultySelect.value = loadedData.difficulty;
    await init(loadedData);
    restoreTableData(loadedData.sessionData);

    // If the saved snapshot includes result/isCorrect, render it and skip re-checking
    const hasSavedResults = Object.values(loadedData.sessionData || {}).some(r => r && (r.result || typeof r.isCorrect === 'boolean'));
    if (hasSavedResults) {
      Object.entries(loadedData.sessionData || {}).forEach(([rowId, rowData]) => {
        const row = document.getElementById(rowId);
        if (!row || !rowData) return;

        // Reapply correctness styling if it was marked correct
        if (rowData.isCorrect) {
          row.classList.add('is-correct');
          row.style.backgroundColor = '#f0fff4';
        }

        // Restore the exact saved result output (keeps ‚úì/‚úó and styling)
        const resultCell = row.querySelector('[data-col="result"]');
        if (resultCell && rowData.result) {
          resultCell.innerHTML = rowData.result;
        }

        // Lock inputs for all rows
        const densityCell = row.querySelector('[data-col="density"]');
        const idSelect = row.querySelector('[data-col="identification"]');
        if (densityCell) densityCell.contentEditable = false;
        if (idSelect) idSelect.disabled = true;
      });

      // Show saved score
      const scoreDisplay = document.getElementById('score-display');
      scoreDisplay.classList.remove('hidden');
      scoreDisplay.textContent = `Score: ${loadedData.score}%`;
    } else {
      // Fallback to current behavior if no saved results were captured
      checkAnswers();
    }

    // Lock the page into read-only viewing mode
    document.querySelectorAll('[contenteditable="true"]').forEach(el => el.contentEditable = false);
    document.querySelectorAll('select').forEach(el => el.disabled = true);
    checkAnswersBtn.textContent = "View Results";
    exportBtn.disabled = false;
    exportBtn.textContent = 'üì§ Forward / Re-Share';
    resetBtn.disabled = true;
    resetBtn.style.opacity = '0.5';

    return true;
  } catch (error) {
    console.error("Failed to import data:", error);
    alert("The provided link is invalid or corrupted. Starting a new session.");
    window.history.replaceState({}, document.title, window.location.pathname);
    return false;
  }
}

  // Layout
  function createLabLayout() {
    labArea.innerHTML = '';
    const controlsContainer = document.createElement('div');
    controlsContainer.className = 'flex-shrink-0 flex flex-col items-center p-2';
    const liquidDensityLabel = createLabElement('liquid-density-label', 'Liquid Density: <span id="liquid-density-value">1.00</span> g/mL', 'block text-center font-semibold mb-2 w-64');
    liquidDensitySlider = createLabElement('liquid-density-slider', '', 'w-64 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer', 'input');
    Object.assign(liquidDensitySlider, { type: 'range', min: 0.5, max: 2.0, value: 1.0, step: 0.01 });
    controlsContainer.append(liquidDensityLabel, liquidDensitySlider);

    const floorContainer = document.createElement('div');
    floorContainer.className = 'flex-grow flex justify-around items-end pb-4';

    const scaleWrapper = document.createElement('div');
    scaleWrapper.className = 'flex flex-col items-center relative';
    scaleEl = createLabElement('scale', 
      `<div class="absolute bottom-0 w-full h-8 bg-gray-600 rounded-b-lg"></div>
       <div class="absolute bottom-8 w-5/6 h-12 bg-gray-500 -skew-x-12 left-0 rounded-tl-md"></div>
       <div class="absolute bottom-8 w-5/6 h-12 bg-gray-500 skew-x-12 right-0 rounded-tr-md"></div>
       <div id="scale-readout" class="absolute bottom-9 bg-gray-800 text-cyan-300 font-mono text-3xl w-40 h-12 flex items-center justify-center rounded-lg shadow-inner border-2 border-cyan-600">0.00</div>
       <div id="scale-platform" class="absolute top-0 w-44 h-4 bg-gray-400 rounded-t-md border-b-2 border-gray-500"></div>`, 'relative w-56 h-24');
    scaleWrapper.append(scaleEl);

    const beakerWrapper = document.createElement('div');
    beakerWrapper.className = 'flex items-end gap-4';
    const beakerAndSlider = document.createElement('div');
    beakerAndSlider.className = 'flex items-end gap-2';
    initialWaterSlider = createLabElement('initial-water-slider', '', 'h-48', 'input');
    Object.assign(initialWaterSlider, { type: 'range', min: 50, max: 200, value: 100, step: 1 });
    initialWaterSlider.setAttribute('orient', 'vertical');
    beakerEl = createLabElement('beaker', '<div id="water" class="water"><div class="water-surface"></div></div><div class="beaker-markings"><span data-label="50"></span><span data-label="100"></span><span data-label="150"></span><span data-label="200"></span><span data-label="250"></span><span data-label="300"></span></div>', 'beaker');
    waterEl = beakerEl.querySelector('#water');
    const volumeReadoutEl = createLabElement('volume-readout-bg', '<span id="volume-readout">100.0</span> mL', 'bg-gray-800 text-white font-mono text-2xl p-3 rounded-lg text-center shadow-md mb-4');
    beakerAndSlider.append(initialWaterSlider, beakerEl);
    beakerWrapper.append(beakerAndSlider, volumeReadoutEl);

    floorContainer.append(scaleWrapper, beakerWrapper);
    labArea.append(controlsContainer, floorContainer, overflowWarning, measurementHint);
  }

  async function init(loadedData = null) {
    createLabLayout();
    objects = [];
    sessionData = loadedData ? loadedData.sessionData : {};
    knownObjectContainer.innerHTML = '';
    mysteryObjectContainer.innerHTML = '';
    knownResultsBody.innerHTML = '';
    mysteryResultsBody.innerHTML = '';
    score = loadedData ? loadedData.score : 0;
    document.getElementById('score-display').classList.add('hidden');

    currentDifficulty = parseInt(difficultySelect.value);
    const cfg = DIFFICULTY_CONFIG[currentDifficulty];

    // Known list for this level
    const selectedKnown = cfg.knownMaterials.map(id => KNOWN_MATERIALS_REPO.find(m => m.id === id)).filter(Boolean);

    // Render known objects + rows
    selectedKnown.forEach(mat => addObjectToSim(mat, false));

    // Build mystery list from known list, random unique picks
    const mysteryMaterials = pickRandomUnique(selectedKnown, cfg.mysteryCount);
    const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    mysteryMaterials.forEach((mat, idx) => {
      const style = MYSTERY_STYLE_POOL[idx % MYSTERY_STYLE_POOL.length];
      const mystery = {
        id: labels[idx],
        answerId: mat.id,
        color: style.color,
        shape: style.shape,
        size: style.size
      };
      addObjectToSim(mystery, true);
    });

    // Reset controls
    liquidDensity = 1.0; initialWaterLevel = 100;
    document.getElementById('liquid-density-value').textContent = '1.00';
    liquidDensitySlider.value = 1.0; initialWaterSlider.value = 100;
    updateWaterLevel(0);
    document.getElementById('scale-readout').textContent = '0.00';
    addEventListeners();
  }

  function pickRandomUnique(arr, count) {
    const pool = [...arr];
    const result = [];
    while (pool.length && result.length < count) {
      const i = Math.floor(Math.random() * pool.length);
      result.push(pool.splice(i, 1)[0]);
    }
    return result;
  }

  function addObjectToSim(baseData, isMystery) {
    const cfg = DIFFICULTY_CONFIG[currentDifficulty];
    const errorFactor = cfg.measurementError || 0;
    const volumeVariation = 0.9 + Math.random() * 0.2;
    const baseMaterial = isMystery ? KNOWN_MATERIALS_REPO.find(m => m.id === (baseData.answerId || baseData.id)) : baseData;
    if (!baseMaterial) return;

    const trueVolume = baseMaterial.baseVolume * volumeVariation;
    const trueMass = baseMaterial.density * trueVolume;
    const measurementErrorMass = errorFactor > 0 ? (1 + (Math.random() - 0.5) * errorFactor) : 1;
    const measurementErrorVolume = errorFactor > 0 ? (1 + (Math.random() - 0.5) * errorFactor) : 1;
    const measuredMass = trueMass * measurementErrorMass;
    const measuredVolume = trueVolume * measurementErrorVolume;

    const name = baseData.name || baseData.id;
    const instanceData = { 
      ...baseData, 
      mass: measuredMass,
      volume: measuredVolume,
      trueDensity: baseMaterial.density,
      name, isMystery 
    };

    const objEl = createLabElement(`obj-${instanceData.id}`, 
      `<span class="font-bold ${isMystery ? 'text-xl' : 'text-sm'} text-slate-800 pointer-events-none">${isMystery ? instanceData.id : name}</span>`, 
      `lab-object grab shadow-md ${instanceData.color || 'bg-slate-200'} ${instanceData.shape || 'rounded-md'} ${instanceData.size || 'w-10 h-10'}`);
    const container = isMystery ? mysteryObjectContainer : knownObjectContainer;
    container.appendChild(objEl);

    objects.push({
      el: objEl, data: instanceData, x: 0, y: 0, vx: 0, vy: 0,
      isDragging: false, isOnScale: false, isInBeaker: false, isInLab: false,
      // scale latch state
      scaleLatched: false, scaleOffFrames: 0, scaleStableFrames: 0
    });

    const options = '<option value="">Select...</option>' + KNOWN_MATERIALS_REPO.map(m => `<option value="${m.id}">${m.name || m.id}</option>`).join('');
    const row = createLabElement(`row-${instanceData.id}`, 
      `<td class="p-2 font-bold">${isMystery ? `Object ${instanceData.id}` : name}</td>
       <td class="p-2" contenteditable="true" data-col="mass"></td>
       <td class="p-2" contenteditable="true" data-col="volume"></td>
       <td class="p-2" contenteditable="true" data-col="density"></td>
       ${isMystery ? `<td class="p-2"><select data-col="identification" class="w-full bg-white border border-slate-300 rounded-md p-1 text-xs">${options}</select></td><td class="p-2 text-center" data-col="result"></td>` : ''}`,
      'border-b', 'tr');
    const tableBody = isMystery ? mysteryResultsBody : knownResultsBody;
    tableBody.appendChild(row);
  }

  function addEventListeners() {
    liquidDensitySlider.addEventListener('input', (e) => {
      liquidDensity = parseFloat(e.target.value);
      document.getElementById('liquid-density-value').textContent = liquidDensity.toFixed(2);
    });
    initialWaterSlider.addEventListener('input', (e) => {
      initialWaterLevel = parseFloat(e.target.value);
      if (!objects.some(o => o.isInBeaker)) updateWaterLevel(0);
    });
  }

  function checkAnswers() {
    const rows = mysteryResultsBody.querySelectorAll('tr');
    const total = rows.length;
    if (!total) return;

    const scoreDisplay = document.getElementById('score-display');
    scoreDisplay.classList.remove('hidden');

    let correct = 0;
    rows.forEach(row => {
      if (row.classList.contains('is-correct')) { correct++; return; }

      const densityCell = row.querySelector('[data-col="density"]');
      const idSelect = row.querySelector('[data-col="identification"]');
      const resultCell = row.querySelector('[data-col="result"]');
      const objId = row.querySelector('td').textContent.replace('Object ', '').trim();
      
      const userDensity = parseFloat(densityCell.textContent);
      const userId = idSelect.value;
      const mysteryObj = objects.find(o => o.data.isMystery && o.data.id === objId);
      if (!mysteryObj) return;

      const isComplete = !isNaN(userDensity) && userId;
      if (!isComplete) {
        resultCell.innerHTML = '<span class="text-gray-400">Incomplete</span>';
      } else {
        const trueDensity = mysteryObj.data.trueDensity;
        const answerId = mysteryObj.data.answerId;
        const isDensityCorrect = Math.abs((userDensity - trueDensity) / trueDensity) * 100 < 5;
        const isIdCorrect = userId === answerId;

        if (isDensityCorrect && isIdCorrect) {
          resultCell.innerHTML = '<span class="feedback-icon text-green-600">‚úì Correct!</span>';
          row.classList.add('is-correct');
          densityCell.contentEditable = false;
          idSelect.disabled = true;
          row.style.backgroundColor = '#f0fff4';
          correct++;
        } else {
          const feedback = [];
          if (!isDensityCorrect) feedback.push("Density wrong");
          if (!isIdCorrect) feedback.push("ID wrong");
          resultCell.innerHTML = `<span class="feedback-icon text-red-500">‚úó ${feedback.join(', ')}</span>`;
        }
      }
    });

    score = Math.round((correct / total) * 100);
    scoreDisplay.textContent = `Score: ${score}%`;
    if (correct === total && total > 0) {
      scoreDisplay.innerHTML += ' <span class="text-green-600 font-bold">üéâ Complete!</span>';
    }
  }

  // Dragging
  function startDrag(e) {
    const target = e.target.closest('.lab-object');
    if (!target) return;
    e.preventDefault();

    draggedObject = objects.find(o => o.el === target);
    if (!draggedObject) return;

    draggedObject.isDragging = true;
    draggedObject.el.classList.add('grabbing');
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    const labRect = labArea.getBoundingClientRect();

    if (!draggedObject.isInLab) {
      draggedObject.isInLab = true;
      const rect = draggedObject.el.getBoundingClientRect();
      labArea.appendChild(draggedObject.el);
      draggedObject.el.style.position = 'absolute';
      draggedObject.x = rect.left - labRect.left;
      draggedObject.y = rect.top - labRect.top;
      draggedObject.el.style.left = `${draggedObject.x}px`;
      draggedObject.el.style.top = `${draggedObject.y}px`;
    }
    
    draggedObject.offsetX = clientX - (labRect.left + draggedObject.x);
    draggedObject.offsetY = clientY - (labRect.top + draggedObject.y);
    draggedObject.vx = 0;
    draggedObject.vy = 0;
    draggedObject.scaleLatched = false;
    draggedObject.scaleOffFrames = 0;
    draggedObject.scaleStableFrames = 0;

    measurementHint.classList.remove('hidden');
  }

  function drag(e) {
    if (!draggedObject) return;
    e.preventDefault();
    
    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
    const labRect = labArea.getBoundingClientRect();

    draggedObject.x = clientX - labRect.left - draggedObject.offsetX;
    draggedObject.y = clientY - labRect.top - draggedObject.offsetY;

    draggedObject.el.style.left = `${draggedObject.x}px`;
    draggedObject.el.style.top = `${draggedObject.y}px`;
  }

  function endDrag() {
    if (!draggedObject) return;

    draggedObject.isDragging = false;
    draggedObject.el.classList.remove('grabbing');
    
    const beakerRect = beakerEl.getBoundingClientRect();
    const scaleRect = scaleEl.getBoundingClientRect();
    
    const objRect = draggedObject.el.getBoundingClientRect();
    const objCenterX = objRect.left + objRect.width / 2;
    const objCenterY = objRect.top + objRect.height / 2;
    
    if (objCenterY > scaleRect.top && objCenterX > scaleRect.left && objCenterX < scaleRect.right) {
      draggedObject.isOnScale = true;
      draggedObject.scaleLatched = true;
      draggedObject.scaleOffFrames = 0;
      draggedObject.scaleStableFrames = 0;
      draggedObject.isInBeaker = false;
    } else if (objCenterX > beakerRect.left && objCenterX < beakerRect.right && objCenterY < beakerRect.bottom) {
      draggedObject.isInBeaker = true;
      draggedObject.isOnScale = false;
      draggedObject.scaleLatched = false;
    } else {
      draggedObject.isOnScale = false;
      draggedObject.isInBeaker = false;
      draggedObject.scaleLatched = false;
    }

    // Return to shelf if dropped over shelf
    const shelves = [knownObjectContainer, mysteryObjectContainer];
    for (const shelf of shelves) {
      const shelfRect = shelf.getBoundingClientRect();
      if (objCenterX > shelfRect.left && objCenterX < shelfRect.right && objCenterY > shelfRect.top && objCenterY < shelfRect.bottom) {
        returnToShelf(draggedObject);
        break;
      }
    }
    
    measurementHint.classList.add('hidden');
    draggedObject = null;
  }
  
  function returnToShelf(obj) {
    obj.isInLab = false;
    obj.isOnScale = false;
    obj.isInBeaker = false;
    obj.scaleLatched = false;
    obj.el.style.position = 'relative';
    obj.el.style.left = '';
    obj.el.style.top = '';
    obj.el.style.transform = '';
    obj.x = 0; obj.y = 0; obj.vx = 0; obj.vy = 0;
    
    const container = obj.data.isMystery ? mysteryObjectContainer : knownObjectContainer;
    container.appendChild(obj.el);
    updateScaleReadout();
    updateWaterLevel(0);
  }

  // Main loop
  function gameLoop() {
    const labRect = labArea.getBoundingClientRect();
    const scalePlatform = document.getElementById('scale-platform').getBoundingClientRect();
    const beakerRect = beakerEl.getBoundingClientRect();

    // Sum displaced volume from all objects in the beaker
    let totalDisplacedVolume = 0;

    objects.forEach(obj => {
      if (!obj.isInLab) return;

      if (obj.isDragging) {
        // Update beaker membership while dragging (slightly expanded zone)
        const objRect = obj.el.getBoundingClientRect();
        obj.isInBeaker = (objRect.right > beakerRect.left - 4) && (objRect.left < beakerRect.right + 4) && (objRect.bottom > beakerRect.top);
      } else {
        // Scale latching zone with hysteresis
        handleScaleZone(obj, labRect, scalePlatform);

        if (obj.scaleLatched) {
          // Hard clamp on platform
          obj.vy = 0;
          obj.vx *= 0.85;
          const platformY = scalePlatform.top - labRect.top - obj.el.offsetHeight;
          obj.y = platformY;
        } else {
          // Beaker physics if horizontally overlapping
          if (isOverBeakerHoriz(obj, beakerRect)) {
            handleBeakerPhysics(obj, beakerRect, labRect);
          } else {
            obj.isInBeaker = false;
            obj.vy += gravity;
          }

          // Integrate motion
          obj.x += obj.vx;
          obj.y += obj.vy;

          // Clamp speeds (global)
          if (obj.vy > maxVyOverall) obj.vy = maxVyOverall;
          if (obj.vy < -maxVyOverall) obj.vy = -maxVyOverall;

          // Secondary clamp for beaker bottom after integration
          if (obj.isInBeaker) {
            const beakerBottomY = beakerRect.bottom - labRect.top - obj.el.offsetHeight;
            if (obj.y > beakerBottomY) { obj.y = beakerBottomY; obj.vy = 0; }
          }

          // Boundaries
          handleBoundaries(obj, labRect);
        }
      }

      // Displacement contribution if in beaker (after potential state updates)
      if (obj.isInBeaker) {
        const objRect = obj.el.getBoundingClientRect();
        const waterSurfaceY = beakerRect.bottom - waterEl.offsetHeight;
        const submergedHeight = Math.max(0, objRect.bottom - waterSurfaceY);
        const submergedRatio = Math.min(1, submergedHeight / objRect.height);
        totalDisplacedVolume += obj.data.volume * submergedRatio;
      }

      // Paint
      obj.el.style.left = `${obj.x}px`;
      obj.el.style.top = `${obj.y}px`;
    });

    // Update water level with sum of displaced volumes
    updateWaterLevel(totalDisplacedVolume);

  // Stable cumulative scale readout
const stableLatched = objects.filter(
  o => o.scaleLatched && o.scaleStableFrames >= scaleStableThreshold
);

if (stableLatched.length) {
  lastStableScaleMass = stableLatched.reduce((sum, o) => sum + o.data.mass, 0);
} else {
  // If nothing latched at all, return to zero; if something is latching
  // but not yet stable, keep prior reading to avoid flicker.
  if (!objects.some(o => o.scaleLatched)) {
    lastStableScaleMass = 0;
  }
}

updateScaleReadout();

    window.animationFrameId = requestAnimationFrame(gameLoop);
  }

  function handleScaleZone(obj, labRect, scalePlatform) {
    const objRect = obj.el.getBoundingClientRect();
    const platformLeft = scalePlatform.left - scaleLatchBufferX;
    const platformRight = scalePlatform.right + scaleLatchBufferX;
    const platformYTop = scalePlatform.top - scaleLatchBufferY;
    const platformY = scalePlatform.top;

    const horizontallyAligned = objRect.right > platformLeft && objRect.left < platformRight;
    const nearTop = objRect.bottom >= platformYTop && objRect.bottom <= platformY + 16; // small window below too

    if (horizontallyAligned && nearTop && obj.vy >= 0) {
      // Enter or remain latched
      obj.scaleLatched = true;
      obj.isOnScale = true;
      obj.scaleOffFrames = 0;
      obj.scaleStableFrames++;
      // Snap to exact platform top
      obj.y = platformY - labRect.top - obj.el.offsetHeight;
      obj.vy = 0;
    } else if (obj.scaleLatched) {
      // Hysteresis: only release if off-zone for several frames
      obj.scaleOffFrames++;
      if (obj.scaleOffFrames > scaleReleaseFrames) {
        obj.scaleLatched = false;
        obj.isOnScale = false;
        obj.scaleStableFrames = 0;
        obj.scaleOffFrames = 0;
      }
    } else {
      obj.isOnScale = false;
      obj.scaleStableFrames = 0;
      obj.scaleOffFrames = 0;
    }
  }

  function isOverBeakerHoriz(obj, beakerRect) {
    const objRect = obj.el.getBoundingClientRect();
    // Expanded slightly to avoid rapid toggling
    return (objRect.right > beakerRect.left - 4) && (objRect.left < beakerRect.right + 4) && (objRect.top < beakerRect.bottom);
  }


// REPLACE your existing handleBeakerPhysics with this one

function handleBeakerPhysics(obj, beakerRect, labRect) {
    const objRect = obj.el.getBoundingClientRect();
    const waterSurfaceY = beakerRect.bottom - waterEl.offsetHeight;

    // Consider inside if overlapping in both axes (with a small tolerance)
    obj.isInBeaker = !(
        objRect.right  < beakerRect.left + 2 ||
        objRect.left   > beakerRect.right - 2 ||
        objRect.bottom < beakerRect.top + 2 ||
        objRect.top    > beakerRect.bottom
    );

    // Beaker walls
    const beakerLeft = beakerRect.left - labRect.left;
    const beakerRight = beakerRect.right - labRect.left - obj.el.offsetWidth;
    if (obj.x < beakerLeft)  { obj.x = beakerLeft;  obj.vx *= -0.4; }
    if (obj.x > beakerRight) { obj.x = beakerRight; obj.vx *= -0.4; }

    // Beaker bottom (pre-integration guard)
    const beakerBottomY = beakerRect.bottom - labRect.top - obj.el.offsetHeight;
    if (obj.y > beakerBottomY) { obj.y = beakerBottomY; obj.vy = 0; }

    // Submergence (0..1) based on how much of the object is below the water surface
    const submergedHeight = Math.max(0, objRect.bottom - waterSurfaceY);
    const submergedRatio  = Math.min(1, submergedHeight / objRect.height);

    if (submergedRatio > 0) {
        // Densities (g/mL) ‚Üí dimensionless buoyancy factor for current submergence
        const rhoObj = obj.data.trueDensity;
        const rhoLiq = liquidDensity;

        // Net vertical acceleration (positive is downward in this sim):
        // a_net = g - (Fb/m) = g * (1 - (rho_liq / rho_obj) * submergedRatio)
        const buoyFactor = (rhoLiq / rhoObj) * submergedRatio;
        const aNet = gravity * (1 - buoyFactor);
        obj.vy += aNet;

        // In-water drag on both axes
        obj.vx *= waterLinearDrag;
        obj.vy *= waterLinearDrag;

        // Extra damping at the surface for floaters (lighter than the liquid) to kill bobbing quickly
        if (submergedRatio < 1 && rhoObj < rhoLiq) {
            obj.vy *= surfaceDamping;
        }

        // Cap vertical speed in water to prevent tunneling/instability
        if (typeof maxVyInWater === 'number') {
            if (obj.vy >  maxVyInWater) obj.vy =  maxVyInWater;
            if (obj.vy < -maxVyInWater) obj.vy = -maxVyInWater;
        }
    } else {
        // Not submerged yet ‚Üí normal gravity (object above the surface)
        obj.vy += gravity;
    }
}


  function handleBoundaries(obj, labRect) {
    const objRect = obj.el.getBoundingClientRect();
    if (obj.x < 0) { obj.x = 0; obj.vx *= -0.5; }
    if (obj.x + objRect.width > labRect.width) { obj.x = labRect.width - objRect.width; obj.vx *= -0.5; }
    if (obj.y < 0) { obj.y = 0; obj.vy = 0; }
    if (obj.y + objRect.height > labRect.height) {
      obj.y = labRect.height - objRect.height;
      obj.vy = 0;
      obj.vx *= 0.9;
    }
  }

  function updateWaterLevel(totalDisplacedVolume) {
    let currentWaterVolume = initialWaterLevel + (totalDisplacedVolume || 0);
    const overflow = currentWaterVolume > beakerCapacity;
    overflowWarning.classList.toggle('hidden', !overflow);
    waterEl.classList.toggle('overflow', overflow);
    currentWaterVolume = Math.min(currentWaterVolume, beakerCapacity);

    waterEl.style.height = `${currentWaterVolume * waterHeightPerML}px`;
    document.getElementById('volume-readout').textContent = (initialWaterLevel + (totalDisplacedVolume || 0)).toFixed(1);
  }

  function updateScaleReadout() {
    document.getElementById('scale-readout').textContent = lastStableScaleMass.toFixed(2);
  }

  // Utilities
  function createLabElement(id, innerHTML, className, type = 'div') {
    const el = document.createElement(type);
    if (id) el.id = id;
    if (className) el.className = className;
    if (innerHTML) el.innerHTML = innerHTML;
    return el;
  }

  function restoreTableData(data) {
    if (!data) return;
    Object.keys(data).forEach(rowId => {
      const row = document.getElementById(rowId);
      if (!row) return;
      const rowData = data[rowId];
      const massCell = row.querySelector('[data-col="mass"]');
      if (massCell && rowData.mass) massCell.textContent = rowData.mass;
      const volumeCell = row.querySelector('[data-col="volume"]');
      if (volumeCell && rowData.volume) volumeCell.textContent = rowData.volume;
      const densityCell = row.querySelector('[data-col="density"]');
      if (densityCell && rowData.density) densityCell.textContent = rowData.density;
      const idSelect = row.querySelector('[data-col="identification"]');
      if (idSelect && rowData.identification) idSelect.value = rowData.identification;
    });
  }

  // Init
  (async () => {
    const imported = await handleImport();
    if (!imported) await init();
    gameLoop();
  })();
});
</script>
</body>
</html>
